

\section{IMPLEMENTATION}
Our system is a C/C++ compiler built on the Clang/LLVM compiler framework. Any application wishing to be protected by Peapods must be recompiled along with all of its dependencies.

The LLVM module pass provides the sensitive variable identification logic, sensitive information encryption and decryption logic we need.

\subsection{Utility functions}


We encapsulate the XBEGIN and XEND instructions in user mode into utility functions START and END.They are used to start transactions and end transactions respectively.In addition,We also encapsulate an Utility functions TEM to split transactions.

%插入图
\subsection{Master key protection}
The master key needs to be saved in the system for a long time.The master key must be tightly protected, otherwise it will pose a threat to data security throughout the system.As persistent sensitive information, the master key is always stored in secure storage in clear text whether or not the sensitive information calculation is to be performed.For physical memory attacks in memory disclosure attacks, any storage area that can restrict access only at the software level is insecure. Secure storage should have physical mechanisms to restrict access.Each CPU core or each hardware thread has a separate set of registers that can only be read by the currently executing instruction.Therefore, the register is the storage resource that runs the program exclusive and it is an ideal secure storage. At the same time, XMM registers are mainly used for floating point and vector operations. Excluding a small number of XMM registers does not have a significant impact on performance in non-massive floating point computing environments.Therefore, we decided to store the master key in the XMM register.

The master key is randomly generated by the rdrand instruction at program startup.Then it is stored in the XMM7 register without any memory operations.In the LLVM backend, we set the XMM7 register as a reserved register.At last,user-level threading libraries have also made corresponding changes to prevent the value of XMM7 register from leaking into memory.
%rdrand指令产生随机数
%汇编语言直接操作寄存器，没有涉及内存操作
%XMM寄存器设置为保留寄存器
%user-level threading libraries 也做了相应的改动避免这些寄存器的值泄漏到内存


\subsection{sensitive variables Identification}

%4种不同变量的识别和保护
We divided the sensitive variables into three categories: (1) local variable that address was already determined at compile time, (2) global variable or static variable that address was already determined at compile time, (3) variable that address was not determined at compile time.
For sensitive variables whose compile-time addresses have been determined, such as sensitive variables for array types, structure types (members without pointer-type variables), we provide the user with the new \textbf{keyword}: attribute ((annotation "Private Key")) when the user defining a sensitive data variable of this type, they need to add the keyword to the variable definition.Peapods will identify the variable that has been marked as sensitive data. If it is a local variable, it inserts the XBEGIN instruction before the instruction it defines, and inserts the instruction following its defined instruction: (1)The intermediate byte code of the logic of use the master key pair to encrypt this variable with AES encryption of the CBC mode, and (2) the XEND instruction.Therefore, when these local variables are initialized in the way defined, the sensitive variables are stored in ciphertext in memory. Before the XEND instruction, Peapods will carefully clear the intermediate states used in this stage;If it is a global variable or static variable, the AES encryption of the CBC mode of all recognized global variables is completed at the time of program initialization.

For sensitive variables with undecided compile-time addresses, such as pointer-type sensitive variables, since the address and length of sensitive variables cannot be obtained at compile time, the user is required to provide information of such sensitive variables. Then, the user uses the specified structure passes the parameters in the utility function provided by us, and Peapods will automatically encrypt and decrypt all the sensitive variables in the structure.

%结构体代码

\lstset{
    numbers=left,
    numberstyle= \tiny,
    keywordstyle= \color{ blue!70},
    commentstyle= \color{red!50!green!50!blue!50},
    frame=shadowbox, % 阴影效果
    rulesepcolor= \color{ red!20!green!20!blue!20} ,
    escapeinside=``, % 英文分号中可写入中文
    xleftmargin=2em,xrightmargin=2em, aboveskip=1em,
    framexleftmargin=2em
}
\begin{lstlisting}
struct args{
    unsigned char *data;
    int len;
    struct args* next;
}*args_list,args_list_next;
\end{lstlisting}

When users want to assign values to sensitive variables, they need to call START(args\_list) before assigning sensitive variables and END(args\_list) after assigning values.In IR PASS, we add logic to automatically encrypt and decrypt sensitive variables in utility functions such as START and END. In this way, the entire assignment process is performed under transaction protection. After the transaction is started, the sensitive variables are decrypted, and then encrypt sensitive variables before ending the transaction. Therefore, there is always only a ciphertext sensitive variable in memory.

It is worth noting that reading and writing files within a transaction will cause the transaction to abort. Therefore, Peapods cannot provide security protection during the assignment phase if the user reads a file to assign sensitive variables.In fact, in this case, the user can still call START(args list) after reading the file, call END(args list) after assignment, and clear the plaintext intermediate variable to make the sensitive variable exist in ciphertext after the assignment.However, in the process of reading a file, sensitive information is exposed in memory in the form of clear text. It is assumed that there is no memory disclosure attack at this time.At the same time, there is a backup of sensitive information in the hard disk. An attacker can also read the hard disk to obtain sensitive information. The user needs to delete the file containing sensitive information after reading the file.

\subsection{Sensitive information protection}
We need to consider time interruptions during the calculation. The calculation of sensitive information (such as private keys) is usually relatively time-consuming. Therefore, the execution of a transaction that would otherwise be successful may be terminated by a time interruption.In addition, other interrupts can also cause the transaction to terminate.The solution to other kernel-mode memoryless encryption schemes is to disable interrupts,such as TRESOR, PRIME, Copker and Mimosa. We propose transaction split, a method for breaking time-consuming large transactions into multiple small transactions.

The design of the transaction split is mainly to achieve the following goals:
1.Even if the entire time-consuming calculation is not completed, we can still save some time-consuming intermediate calculation results. When the transaction occurs abort, we can use these already calculated intermediate calculation results to start the next calculation.
2.Compared to transactions that were not split prior to the entire calculation, only a small number of CPU clock cycles were consumed in each transaction and only a small amount of memory space was occupied. Therefore, these small transactions are easier to submit successfully.

Since the introduction of transaction splitting, the entire calculation is no longer an atomic operation, we need to encrypt the calculated intermediate calculation results using the AES master key before the transaction ends, and then perform AES decryption after the start of the next transaction to ensure security outside the transaction.These security logic are automatically implemented when the TEM function is called

After we split a PolarSSL RSA decryption calculation into 128 times, the program performs well.

We provide users with three utility functions.We track all function call instructions in IR PASS, recognize the call to START, END, and TEM. Then we insert the corresponding intermediate representation code of encryption and decryption before the END function call instruction, after the START function call instruction, and both before and after the TEM function call instruction respectively.

\begin{table}[htbp]
 \caption{\label{tab:libfunc} Utility functions list}
 \centering
 \begin{tabular}{|c|c|p{3cm}<{\centering} | p{5cm}<{\centering} |}
  \hline
  \textbf{Function Name} & \textbf{Function} & \textbf{Usage Method} & \textbf{Implementation logic} \\
  \hline
  T\_START(args\_list) & Start a transaction & Used before sensitive operations begin & (1)XBEGIN；(2)get the master key from the XMM7 register；(3)generate AES context using the master key；(4)AES decryption of CBC mode for identified sensitive data variables \\
  \hline
  T\_END(args\_list) & End a transaction & Used after sensitive operations end & (1)AES encryption of CBC mode for identified sensitive data variables；(2)Erase intermediate results；(3)XEND \\
  \hline
  T\_SPLIT(args\_list) & Split a transaction & Used in locations where transactions need to be split within the transaction & (1)AES encryption of CBC mode for identified sensitive data variables；(2)Generate intermediate variable IV, then randomly initialize and perform AES encryption of CBC mode for the intermediate variables passed in by the user.；(3)Erase intermediate results；(4)XEND；(5)XBEGIN；(6)get the master key from the XMM7 register；(7)generate AES context using the master key；(8)AES decryption of CBC mode for identified sensitive data variables \\
  \hline
 \end{tabular}
\end{table}
%三个功能函数的具体实现细节表
\subsection{Page fault handling}
We protected Polarssl RSA decryption calculations with peapods, during the execution of the program, we used perf, a performance analysis tool to help us knowing the program's operating status. Perf relies on the Intel performance monitoring facility, which supports precision-event-based sampling. This function can record the current processor state when a specific event occurs.We monitored the RTM\_RETIRED.ABORTED event, which was triggered when RTM execution was terminated.Based on the processor status acquired, we can find out the cause of the termination.Perf reported a lot of the termination of the transaction caused by the pages fault. After analysis and exploration, we found that these pages fault mainly come from pages fault of the code segment.

For the pages fault of the code segment, Peapods implements automatic preloading of the code to be executed within the transaction based on LLVM.The basic principle is to insert an empty function before and after the function definition of the function to be executed in the transaction, and to call all the inserted empty functions in the program initialization phase. At this point, the code segment of the function to be executed in the transaction is loaded into memory along with the code segment of the empty function.We traverse all functions in IR PASS and add the corresponding before and after function definitions before and after the function definition.Then, tracking the function calls in all functions, in the corresponding before and after functions, adding the before and after function calls of the functions called in the original function.When there is no function call in the function, only two empty functions are defined.Finally, we add calls to main\_before and main\_after during the initialization phase of the program to implement the call to all before and after functions during the initialization phase.

The above implementation still has some problems:

1.Due to the need to add a new function definition at the location of the function definition, the current solution cannot support automatic preloading of the library function. Our solution is to add a call to a library function such as memset when the program is initialized.For the same reason, the current solution cannot support the automatic preloading of LLVM functions such as llvm.var.annotation. Calling these functions will not result in page fault. We have solved this problem by adding a whitelist filter solution.

2.The current scenario cannot support automatic preloading of functions whose code segment size exceeds one page.According to the pre-loading mechanism, only the contents of the same page as the before and after functions are loaded into memory. If the size of the code segment of a single function exceeds one page, some contents may still not be loaded into memory. This situation will still result in pages fault within the transaction.


\subsection{usage method}
%protected process
Users only need to add a small amount of code when using peapods to automatically implement sensitive information protection.When a user needs to add security enhancements to a certain cryptographic software system, (1) the \_\_attribute\_\_(annotation "Private\_Key") keyword needs to be added before the definition of the sensitive variable of the type whose address has been determined during the compilation, (2) assign pointer-type sensitive variables to the args\_list structure, then pass parameters to the START(args\_list) and END(args\_list) functions, (3) The START(args\_list) function needs to be called before the variable assignment, and the END(args\_list) function is called after the assignment.

In addition, the user needs to call the START(args\_list) function before calculating the sensitive information and call the END(args\_list) function after the sensitive information is calculated.When the sensitive information calculation is too time-consuming, the user needs to call the TEM(args list) function at the split location to split the transaction.

After users complete the above work, Peapods will automatically use HTM to protect sensitive information. Therefore, we can provide security enhancements for various types of cryptographic software systems without refactoring the entire cryptographic software in the presence of security vulnerabilities.The amount of code that the user needs to add is only a few hundred lines to several thousand lines (depending on the number and type of sensitive variables, the number of splits, etc.), the proportion compared to the total code volume of the cryptographic software system (usually several hundred thousand lines) is small.

It is worth noting that all user programs in the system need to be compiled with our modified LLVM compiler to ensure the security of the master key.

\lstset{
    numbers=left,
    numberstyle= \tiny,
    keywordstyle= \color{ blue!70},
    commentstyle= \color{red!50!green!50!blue!50},
    frame=shadowbox, % 阴影效果
    rulesepcolor= \color{ red!20!green!20!blue!20} ,
    escapeinside=``, % 英文分号中可写入中文
    xleftmargin=2em,xrightmargin=2em, aboveskip=1em,
    framexleftmargin=2em,
    basicstyle=\footnotesize,
}
\begin{lstlisting}
__attribute__((annotation"Private_Key")) unsighed char secret[16];

START(args_list);
    secret={\
        0x45,0x46,0x88,0x32,\
        0x2a,0x6d,0x8c,0x31,\
        0x58,0xf2,0x30,0x02,\
        0x4f,0x32,0x7d,0x22\
    };
END(args_list);

START(args_list);
    secret_protect_compute_1();
TEM(args_list);
    secret_protect_compute_2();

    ...

TEM(args_list);
    secret_protect_compute_n();
END(args_list);
\end{lstlisting}
